package outbox

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	domainoutbox "zhanggui/internal/domain/outbox"
)

type WorkerRunInput struct {
	ContextPackDir string
	WorkflowFile   string
}

type WorkResultChanges struct {
	PR     string `json:"PR"`
	Commit string `json:"Commit"`
}

type WorkResultTests struct {
	Command  string `json:"Command"`
	Result   string `json:"Result"`
	Evidence string `json:"Evidence"`
}

type WorkResultEnvelope struct {
	IssueRef   string            `json:"IssueRef"`
	RunID      string            `json:"RunID"`
	ResultCode string            `json:"ResultCode,omitempty"`
	Changes    WorkResultChanges `json:"Changes"`
	Tests      WorkResultTests   `json:"Tests"`
}

func (r WorkResultEnvelope) toDomain() domainoutbox.WorkResult {
	return domainoutbox.WorkResult{
		IssueRef:   r.IssueRef,
		RunID:      r.RunID,
		ResultCode: r.ResultCode,
		Changes: &domainoutbox.WorkChanges{
			PR:     r.Changes.PR,
			Commit: r.Changes.Commit,
		},
		Tests: &domainoutbox.WorkTests{
			Command:  r.Tests.Command,
			Result:   r.Tests.Result,
			Evidence: r.Tests.Evidence,
		},
	}
}

func (s *Service) WorkerRun(ctx context.Context, input WorkerRunInput) error {
	if ctx == nil {
		return errors.New("context is required")
	}
	if err := ctx.Err(); err != nil {
		return err
	}

	contextPackDir := strings.TrimSpace(input.ContextPackDir)
	if contextPackDir == "" {
		return errors.New("context pack dir is required")
	}

	workOrder, err := loadWorkOrder(filepath.Join(contextPackDir, "work_order.json"))
	if err != nil {
		return err
	}
	if err := domainoutbox.ValidateWorkOrder(workOrder); err != nil {
		return err
	}

	profile, err := loadWorkflowProfile(input.WorkflowFile)
	if err != nil {
		return err
	}
	executor := resolveExecutor(profile, workOrder.Role)

	runCtx, cancel := context.WithTimeout(ctx, time.Duration(executor.TimeoutSeconds)*time.Second)
	defer cancel()

	commandText := strings.Join(append([]string{executor.Program}, executor.Args...), " ")
	result := WorkResultEnvelope{
		IssueRef: workOrder.IssueRef,
		RunID:    workOrder.RunID,
		Changes: WorkResultChanges{
			PR:     "none",
			Commit: resolveGitCommit(workOrder.RepoDir),
		},
		Tests: WorkResultTests{
			Command:  commandText,
			Result:   "pass",
			Evidence: "none",
		},
	}
	if strings.TrimSpace(result.Changes.Commit) == "" {
		result.Changes.Commit = "none"
	}

	cmd := exec.CommandContext(runCtx, executor.Program, executor.Args...)
	cmd.Dir = workOrder.RepoDir

	stdoutFile, err := os.Create(filepath.Join(contextPackDir, "stdout.log"))
	if err != nil {
		return err
	}
	defer stdoutFile.Close()

	stderrFile, err := os.Create(filepath.Join(contextPackDir, "stderr.log"))
	if err != nil {
		return err
	}
	defer stderrFile.Close()

	cmd.Stdout = stdoutFile
	cmd.Stderr = stderrFile

	runErr := cmd.Run()
	if runErr != nil {
		result.Tests.Result = "fail"
		if errors.Is(runCtx.Err(), context.DeadlineExceeded) {
			result.ResultCode = "env_unavailable"
		} else {
			result.ResultCode = "test_failed"
		}
	}

	if err := writeWorkResultJSON(filepath.Join(contextPackDir, "work_result.json"), result); err != nil {
		return err
	}
	if err := writeWorkResultText(filepath.Join(contextPackDir, "work_result.txt"), result); err != nil {
		return err
	}
	return nil
}

func loadWorkOrder(path string) (domainoutbox.WorkOrder, error) {
	raw, err := os.ReadFile(path)
	if err != nil {
		return domainoutbox.WorkOrder{}, err
	}

	var order domainoutbox.WorkOrder
	if err := json.Unmarshal(raw, &order); err != nil {
		return domainoutbox.WorkOrder{}, err
	}
	return order, nil
}

func writeWorkResultJSON(path string, result WorkResultEnvelope) error {
	raw, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, raw, 0o644)
}

func writeWorkResultText(path string, result WorkResultEnvelope) error {
	content := fmt.Sprintf(
		"IssueRef: %s\nRunId: %s\nStatus: %s\nPR: %s\nCommit: %s\nTests: %s => %s\nEvidence: %s\nResultCode: %s\n\nNotes:\n- generated by worker runner\n",
		result.IssueRef,
		result.RunID,
		statusFromWorkResult(result),
		noneIfEmpty(result.Changes.PR),
		noneIfEmpty(result.Changes.Commit),
		noneIfEmpty(result.Tests.Command),
		noneIfEmpty(result.Tests.Result),
		noneIfEmpty(result.Tests.Evidence),
		noneIfEmpty(result.ResultCode),
	)
	return os.WriteFile(path, []byte(content), 0o644)
}

func statusFromWorkResult(result WorkResultEnvelope) string {
	if strings.TrimSpace(result.ResultCode) != "" || strings.TrimSpace(result.Tests.Result) == "fail" {
		return "fail"
	}
	return "ok"
}

func resolveGitCommit(repoDir string) string {
	cmd := exec.Command("git", "-C", repoDir, "rev-parse", "HEAD")
	raw, err := cmd.Output()
	if err != nil {
		return ""
	}
	sha := strings.TrimSpace(string(raw))
	if sha == "" {
		return ""
	}
	return "git:" + sha
}

func loadWorkResultFromContextPack(contextPackDir string) (WorkResultEnvelope, error) {
	jsonPath := filepath.Join(contextPackDir, "work_result.json")
	if result, err := loadWorkResultJSON(jsonPath); err == nil {
		return result, nil
	}

	textPath := filepath.Join(contextPackDir, "work_result.txt")
	return loadWorkResultText(textPath)
}

func loadWorkResultJSON(path string) (WorkResultEnvelope, error) {
	raw, err := os.ReadFile(path)
	if err != nil {
		return WorkResultEnvelope{}, err
	}

	var result WorkResultEnvelope
	if err := json.Unmarshal(raw, &result); err != nil {
		return WorkResultEnvelope{}, err
	}
	if strings.TrimSpace(result.IssueRef) == "" || strings.TrimSpace(result.RunID) == "" {
		return WorkResultEnvelope{}, errors.New("work result json missing issue_ref/run_id")
	}
	if strings.TrimSpace(result.Changes.PR) == "" {
		result.Changes.PR = "none"
	}
	if strings.TrimSpace(result.Changes.Commit) == "" {
		result.Changes.Commit = "none"
	}
	if strings.TrimSpace(result.Tests.Result) == "" {
		result.Tests.Result = "n/a"
	}
	if strings.TrimSpace(result.Tests.Command) == "" {
		result.Tests.Command = "none"
	}
	if strings.TrimSpace(result.Tests.Evidence) == "" {
		result.Tests.Evidence = "none"
	}
	return result, nil
}

func loadWorkResultText(path string) (WorkResultEnvelope, error) {
	file, err := os.Open(path)
	if err != nil {
		return WorkResultEnvelope{}, err
	}
	defer file.Close()

	headers := make(map[string]string)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			break
		}
		idx := strings.Index(line, ":")
		if idx <= 0 {
			continue
		}
		key := strings.ToLower(strings.TrimSpace(line[:idx]))
		value := strings.TrimSpace(line[idx+1:])
		headers[key] = value
	}
	if err := scanner.Err(); err != nil {
		return WorkResultEnvelope{}, err
	}

	issueRef := firstNonEmpty(headers["issueref"], headers["issue_ref"])
	runID := firstNonEmpty(headers["runid"], headers["run_id"])
	if issueRef == "" || runID == "" {
		return WorkResultEnvelope{}, errors.New("work result text missing issue_ref/run_id")
	}

	testsValue := firstNonEmpty(headers["tests"], "none")
	testCommand := testsValue
	testResult := "n/a"
	if strings.Contains(testsValue, "=>") {
		parts := strings.SplitN(testsValue, "=>", 2)
		testCommand = strings.TrimSpace(parts[0])
		testResult = strings.TrimSpace(parts[1])
	}
	if testCommand == "" {
		testCommand = "none"
	}
	if testResult == "" {
		testResult = "n/a"
	}

	result := WorkResultEnvelope{
		IssueRef: issueRef,
		RunID:    runID,
		Changes: WorkResultChanges{
			PR:     firstNonEmpty(headers["pr"], "none"),
			Commit: firstNonEmpty(headers["commit"], "none"),
		},
		Tests: WorkResultTests{
			Command:  testCommand,
			Result:   testResult,
			Evidence: firstNonEmpty(headers["evidence"], "none"),
		},
		ResultCode: firstNonEmpty(headers["resultcode"], headers["result_code"]),
	}

	status := strings.ToLower(firstNonEmpty(headers["status"], ""))
	if status == "fail" && strings.TrimSpace(result.ResultCode) == "" {
		result.ResultCode = "test_failed"
	}
	if status == "blocked" && strings.TrimSpace(result.ResultCode) == "" {
		result.ResultCode = "dep_unresolved"
	}
	return result, nil
}

type StructuredCommentInput struct {
	Role         string
	IssueRef     string
	RunID        string
	Action       string
	Status       string
	ReadUpTo     string
	Trigger      string
	Summary      string
	Changes      WorkResultChanges
	Tests        WorkResultTests
	BlockedBy    []string
	OpenQuestion string
	Next         string
}

func buildStructuredComment(input StructuredCommentInput) string {
	blockedBy := normalizeBlockedBy(input.BlockedBy)
	openQuestion := strings.TrimSpace(input.OpenQuestion)
	if openQuestion == "" {
		openQuestion = "none"
	}

	return fmt.Sprintf(
		"Role: %s\nRepo: main\nIssueRef: %s\nRunId: %s\nSpecRef: none\nContractsRef: none\nAction: %s\nStatus: %s\nReadUpTo: %s\nTrigger: %s\n\nSummary:\n- %s\n\nChanges:\n- PR: %s\n- Commit: %s\n\nTests:\n- Command: %s\n- Result: %s\n- Evidence: %s\n\nBlockedBy:\n- %s\n\nOpenQuestions:\n- %s\n\nNext:\n- %s\n",
		noneIfEmpty(input.Role),
		noneIfEmpty(input.IssueRef),
		noneIfEmpty(input.RunID),
		noneIfEmpty(input.Action),
		noneIfEmpty(input.Status),
		noneIfEmpty(input.ReadUpTo),
		noneIfEmpty(input.Trigger),
		noneIfEmpty(input.Summary),
		noneIfEmpty(input.Changes.PR),
		noneIfEmpty(input.Changes.Commit),
		noneIfEmpty(input.Tests.Command),
		noneIfEmpty(input.Tests.Result),
		noneIfEmpty(input.Tests.Evidence),
		blockedBy,
		openQuestion,
		noneIfEmpty(input.Next),
	)
}

func normalizeBlockedBy(values []string) string {
	if len(values) == 0 {
		return "none"
	}
	clean := make([]string, 0, len(values))
	for _, value := range values {
		item := strings.TrimSpace(value)
		if item == "" {
			continue
		}
		clean = append(clean, item)
	}
	if len(clean) == 0 {
		return "none"
	}
	return strings.Join(clean, ", ")
}

func noneIfEmpty(value string) string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return "none"
	}
	return trimmed
}

func firstNonEmpty(values ...string) string {
	for _, value := range values {
		trimmed := strings.TrimSpace(value)
		if trimmed != "" {
			return trimmed
		}
	}
	return ""
}
