# V1.1 补充约定（多环境 + PR 流程 + Outbox 抽象）

本文件是对 `docs/workflow/` 里 V1 协议的补充，目的是把“能稳定跑起来”的关键细节写死，避免实现阶段边写边改协议。

V1 主线请先阅读：

- `docs/workflow/issue-protocol.md`
- `docs/workflow/workflow-profile.md`
- `docs/workflow/lead-worker.md`

## 1) 单一配置真源（只保留 Outbox Repo）

本项目约定：工作流配置只存在于 Outbox repo 内。

- 唯一位置：`<outbox_repo>/.agents/workflow.toml`
- 其它 repo 不应再放 `workflow.toml`（避免多份配置分叉）
- 一个 Outbox repo 对应一个项目，不建议多个项目共用同一个 Outbox（避免线程、标签、审批人与记忆相互污染）

含义：

- 你想改角色集合、并发、审批人、label 语义，只改这一个文件并走 review。
- 实现侧读取这一个文件即可确定“这个项目怎么跑”。

## 2) 多环境运行：用标准目录布局 + 相对路径解决（不引入第二份配置文件）

本次讨论选择：不引入 `workflow.local.toml` 之类的本地覆盖文件。

多环境运行通过两条硬约束达成：

1. 多 repo 项目必须按“同父目录兄弟仓库”的布局 clone。
2. `[repos]` 必须使用相对路径，并约定“相对路径以 `workflow.toml` 所在目录为基准解析”。

推荐目录布局（Outbox repo 通常是 `contracts`）：

```text
<project_root>/
  contracts/   # outbox repo (contains .agents/workflow.toml)
  backend/
  frontend/
```

示例（在 `contracts/.agents/workflow.toml`）：

```toml
[repos]
contracts = "."
backend = "../backend"
frontend = "../frontend"
```

说明：

- 这样 Lead 在任何机器上运行，只要遵守 clone 布局，`repo_dir` 就能正确解析。
- 如果某个 repo 不存在（例如后端-only 项目），就不要在 `roles.enabled` 里启用对应角色，也不要在 `repos` 里配置它。

## 3) Claim 与开工：Assignee 是唯一事实源

V1.1 约定：

- Claim 的真源 = Outbox backend 的 `assignee` 字段（被 assign 才算领取）
  - GitHub/GitLab：issue assignee
  - SQLite：`issues.assignee`
- `/claim` 可以保留为人工提示语，但自动化不应仅凭 comment 文本判定领取成功

前提（务实约束）：

- 对于 GitHub/GitLab backend：Outbox repo 必须允许把 issue assign 给“可被识别的负责人身份”（人类账号或 machine user/bot）。
- 如果仓库策略/权限导致无法 assign（例如不允许给 bot、不给外部协作者 assign），则自动化能力会被削弱。
  - 建议先在 Phase 1 用“人类 assignee + 模板字段 Role/Next”跑通闭环，再单独解决身份与权限问题。
- 对于 SQLite backend：assign 只是更新 thread 的 `assignee` 字段，不存在平台权限问题，但也不具备平台级强认证（见 `docs/operating-model/outbox-backends.md`）

对应状态机（最小）：

- 未领取：`state:todo` 且无 assignee
- 已领取：有 assignee，状态迁移为 `state:doing`
- 阻塞等待：`state:blocked`（可以保留 assignee，不要求清空）
  - 依赖满足后解除阻塞：若 assignee 仍存在则回到 `state:doing`；否则回到 `state:todo`
- 交付验收：`state:review`（附 PR/CI 证据）
- 验收通过：`state:done`
- 最终关闭：由 Approver 关闭 issue（close）

“允许开工（spawn worker）”的最小条件建议为：

- issue open
- assignee 已设置（已 claim）
- `DependsOn` 已满足（resolved/closed）
- 无 `needs-human`

推荐（非硬门槛，但有助于队列清晰与后续自动化）：

- `state:doing` 存在（若缺失，可由 lead/integrator 补齐；Phase 1 不应因此阻塞开工）

## 4) PR 流程（forge 模式：补齐 Outbox 之外的交付闭环）

Issue负责协作真源与状态机；PR 负责代码真源与 review/merge。

说明：

- 本节仅适用于“有 PR 的代码托管平台”（GitHub/GitLab）。
- 如果你是本地/离线模式（只有 git + sqlite，没有 PR），请按 `docs/operating-model/local-first.md` 用 commit hash 作为 Changes，并用 Outbox 事件承接 review 判定（见 `docs/operating-model/quality-gate.md`）。

### 4.1 角色分工（推荐）

- Worker：实现与提交 PR；提供 Tests/CI 证据；不直接合并到主分支。
- Role Lead（backend lead / frontend lead / architect lead）：review PR（approve 或 request changes），并把关键结论回填到 Issue。
- Integrator：负责最终 merge 与跨 repo 的集成验收；把 issue 推进到 `state:done`。
- Approver：负责 `/accept`（如适用）与最终 close issue。

备注：

- Approver 与 Lead 可以是同一个人/身份（配置在 `[approval].approvers`），但两者语义不同：
  - Lead 是“持续负责该 role 的收敛与派工”
  - Approver 是“对决策与关闭拥有最终权限”

### 4.2 Worker 提 PR 的最小要求（强烈建议写入 PR 描述）

- `IssueRef: <owner/repo#number>`（必须；指向 Issue）
- `ContractsRef: <contracts@sha|tag|none>`（建议）
- Tests/CI 证据（至少一项：本地命令输出摘要或 CI 链接）

可选但推荐：

- 使用 `docs/workflow/templates/pr.md` 作为 PR 描述模板（避免不同 worker 写出不一致的结构）

注意：

- 不要依赖“PR 合并自动关闭 issue”的能力（跨 repo、权限、规则都可能导致不一致）。
- V1.1 的关闭真源仍然是 Issue 的状态机与 Approver 的 close 动作。

同时在 Issue 用 comment 模板回填：

- PR 链接
- 当前状态（doing/review/blocked）
- Next 指派（给 lead 或 integrator）

### 4.3 Review 与打回（request changes）如何闭环

当 Lead 在 PR 里 request changes 时，必须同步回填到 Issue（避免信息只留在 PR）：

- 说明“打回原因”（Summary）
- 指向 PR（Changes.PR）
- 指派 Next（Next: @<worker/role> 修复 <具体项>）
- issue 保持 `state:doing`（仍在进行中）

### 4.4 Merge 策略：Integrator 负责最终合并（主策略），Lead 合并是例外

主策略（A，推荐）：

- Integrator 在 PR 满足以下条件后执行 merge：
  - role lead 已 approve
  - CI 通过（或明确说明无 CI 的证据）
  - 依赖顺序满足（contracts -> backend -> frontend）

例外（权限或仓库策略限制）：

- 如果 Integrator 没有某个 repo 的 merge 权限，或 repo 策略要求特定 owner 合并：
  - 对应 role lead 可以代为 merge
  - Integrator 仍负责集成验收与 outbox 状态迁移（review/done）

### 4.5 单仓库 vs 多仓库

- 单仓库：Integrator merge 即可完成闭环。
- 多仓库：职责仍然按 A（Integrator 负责最终合并）执行，只是 Integrator 需要在多个 repo 中完成 merge（前提是各 repo 已获得对应 role lead 的 review/approve）。
- 只有在权限或仓库策略限制时，才会退化为 B（对应 role lead 代为 merge），但 Integrator 仍负责集成验收与 outbox 状态迁移。
- 无论单仓库还是多仓库：协作真源都仍是同一个 Issue（`IssueRef`）。

## 5) Issue 抽象（为 GitLab/MySQL 预留）

为了未来替换承载系统（GitHub -> GitLab/MySQL），建议在协议层把“Issue”抽象为：

- Thread：一个可追加事件的协作线程（唯一主键）
- Event：线程中的一条追加记录（comment/note/row）

Outbox backend 的最小能力集合（概念）：

- ListThreads（按 label/state/assignee 过滤）
- GetThread（取 body/labels/assignee/state）
- AppendEvent（追加 comment，使用固定模板）
- MutateThread（改 labels/assignee/close）

映射示例：

- GitHub：Thread=Issue，Event=Comment
- GitLab：Thread=Issue，Event=Note
- MySQL：Thread=thread 表一行，Event=events 表 append-only

V1 不绑定具体承载系统：可以先用 SQLite 本地 outbox 启动，也可以直接用 GitHub/GitLab Issues；抽象用于保证将来迁移时不推翻协议。

## 6) 分阶段落地计划（统一入口）

分阶段计划已统一收敛到控制平面文档，避免在多个文件里重复维护导致漂移：

- `docs/operating-model/phases.md`
- 本地/离线启动（git + sqlite）：`docs/operating-model/local-first.md`
